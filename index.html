<!DOCTYPE html>
<html> 
<head> 
  <meta name="viewport" content="width=device-width, initial-scale=1">
	<meta content="en-us" http-equiv="Content-Language">
	<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Kewen Peng, Computer Science, North Carolina State University">
  <meta name="author" content="Kewen Peng">
  <meta name="keywords" content="software engineering,data mining, actionable planning, interpretable AI">
	<title>Kewen Peng</title> 
</head> 

<!DOCTYPE html>
<html>

<head>
  <link rel="icon" type="image/png" href="figs/ncsu.png">
  <title>Kewen Peng</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="portfolio.css">
  <link rel="shortcut icon" href="stanford.ico" type="image/x-icon">
</head>

<body>
<div class="container">
  <div class="row">
    <div id="profile-img" class="col-prof-pic cropcircle"></div>
    <div class="col-bio">
      <p align="center" lang="zh-cn"><name>Kewen Peng</name></p>

      <p>I am a Ph.D. student in <a href="https://www.csc.ncsu.edu">Department of Computer Science</a> at <a href="https://www.ncsu.edu">North Carolina State University</a> under the supervision of <a href="http://menzies.us">Dr. Tim Menzies</a>. I joined the Real-world Artificial Intelligence for Software Engineering (<a href="http://ai4se.net/">RAISE</a>) lab in 2019.
      </p>
      
      <p>Before coming to NC State, I earned my B.S. degree of Computer Science from <a href="https://www.wfu.edu/">wake Forest University </a> in 2019, where I also earned my B.A. degree of Mathematics.</p>



      <p align=center>
        <a href="mailto:kpeng@ncsu.edu">Email</a>&nbsp;/&nbsp;
        <a href="CV.pdf">Resume</a>
      </p>
    </div>
  </div>
  
<!--   <div class="row">
  	<heading>News</heading>
  </div> -->
  
  <div class="row">
    <heading>Research</heading>
    <p> My research interests include using data mining and artificial intelligence methods to solve real-world problems in software engineering field. I am also interested in making AI models more explainable and actionable.
    </p>
  </div>
	

  <div class="row">
    <heading>Projects</heading>
  </div>

  <div class="row">
    <subheading>LAS Funded: Fairness and explanation generation</subheading>
    <li><strong>Developing predictive models, measureing fairness in confidential data using various fariness metrics, and generating explanations for better understanding the internal state of black box models.</li>
  </div>


  <div class="row">
    <heading>Publication</heading>
  </div>

  <div class="row">
  <div class="col-proj-pic"><img src="figs/lime.jpg" ></div>
    <div class="col-proj-desc">
      <a href="https://arxiv.org/pdf/2003.06887.pdf">
        <papertitle>How to Improve AI Tools (by Adding in SE Knowledge): Experiments with the TimeLIME Defect Reduction Tool
</papertitle>
      </a><br>
      <strong>Kewen Peng</strong>, <a href="http://menzies.us">Tim Menzies</a>
      <br> Transactions on Software Engineering (<strong>TSE</strong>), 2020 (currently under review) <br>
      <p> Software comes in releases. An implausible change to software is something that has never been changed in prior releases.
When planning how to reduce defects, it is better to use plausible changes, i.e., changes  with some precedence in the prior releases
        
To demonstrate these points, this paper compares several defect reduction planning tools.
LIME is a local sensitivity analysis tool that can report the fewest changes needed to
alter the classification of some code module (e.g.,  from ``defective'' to ``non-defective'').
TimeLIME is a new tool, introduced in this paper, that improves LIME by restricting its plans  to just those attributes which change the most within a project.   

In this study, we compared the performance of LIME and TimeLIME and several  other defect reduction planning algorithms. The generated plans were assessed via (a) the similarity scores between the proposed code changes and the real code changes made by developers; and (b) the improvement scores seen within projects that followed the plans. For nine project trials, we found that TimeLIME  outperformed all other algorithms (in 8 out of 9 trials). Hence, we strongly recommend using past releases as a source of knowledge for computing fixes for new releases (using TimeLIME).

Apart from these specific results about planning defect reductions and TimeLIME, the more general point of this paper is that our community should be more careful about using off-the-shelf AI tools,without first applying SE knowledge. In this case study, it was not difficult to augment a standard AI algorithm with SE knowledge
(that past releases are a good source of knowledge for planning defect reductions). 
As shown here, once that SE knowledge is applied, this can result in dramatically better systems. </p>
    </div>
  </div>
	
  <div class="row">
    <heading>TA Experience</heading>
  </div>

  <div class="row">
    <div class="col-proj-pic"><img src="figs/teaching.png"></div>
        <papertitle>CSC216 Programming Concepts - Java</papertitle><br>
        <br>
  </div>

</body>
</html>
